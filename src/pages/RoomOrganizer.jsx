import React, { useState, useRef, useEffect } from "react";
import { useRoom } from "../context/RoomContext";

// Fonction utilitaire pour obtenir l'ic√¥ne appropri√©e selon le type d'objet
const getObjectIcon = (objectName) => {
  const lowerName = objectName.toLowerCase();
  
  // Mapper les noms d'objets avec leurs ic√¥nes
  if (lowerName.includes('livre') || lowerName.includes('book')) return 'üìö';
  if (lowerName.includes('peluche') || lowerName.includes('teddy') || lowerName.includes('bear')) return 'üß∏';
  if (lowerName.includes('voiture') || lowerName.includes('car')) return 'üöó';
  if (lowerName.includes('ballon') || lowerName.includes('ball')) return '‚öΩ';
  if (lowerName.includes('puzzle') || lowerName.includes('jigsaw')) return 'üß©';
  if (lowerName.includes('poup√©e') || lowerName.includes('doll')) return 'üëß';
  if (lowerName.includes('lego') || lowerName.includes('bloc')) return 'üß±';
  if (lowerName.includes('crayon') || lowerName.includes('pencil')) return '‚úèÔ∏è';
  if (lowerName.includes('jouet') || lowerName.includes('toy')) return 'üéÆ';
  
  // Ic√¥ne par d√©faut
  return 'üß∏';
};

// Fonction pour synth√®se vocale
const speakText = (text) => {
  // V√©rifier si la synth√®se vocale est disponible
  if ('speechSynthesis' in window) {
    // Arr√™ter toute synth√®se en cours
    window.speechSynthesis.cancel();
    
    // Cr√©er une nouvelle instance
    const utterance = new SpeechSynthesisUtterance(text);
    
    // Configurer la voix en fran√ßais
    utterance.lang = 'fr-FR';
    utterance.rate = 0.9;  // L√©g√®rement plus lent pour les enfants
    
    // Trouver une voix fran√ßaise si disponible
    const voices = window.speechSynthesis.getVoices();
    const frenchVoice = voices.find(voice => voice.lang.includes('fr'));
    if (frenchVoice) {
      utterance.voice = frenchVoice;
    }
    
    // Parler
    window.speechSynthesis.speak(utterance);
    return true;
  }
  return false;
};

const RoomOrganizer = () => {
  const { roomImageUrl, detectedObjects, cleanupItems, markItemCleaned, resetCleanup } = useRoom();
  const [isCameraOn, setIsCameraOn] = useState(false);
  const [isDetecting, setIsDetecting] = useState(false);
  const [detectedObjectsState, setDetectedObjects] = useState([]);
  const [lastAnnouncement, setLastAnnouncement] = useState("");
  const [error, setError] = useState(null);
  const [stream, setStream] = useState(null);
  const [detectionResult, setDetectionResult] = useState(null);
  const [isDetectingState, setIsDetectingState] = useState(false);
  const [detectionInterval, setDetectionInterval] = useState(3000);
  const [gameInstructions, setGameInstructions] = useState("");
  const [showUploadedImage, setShowUploadedImage] = useState(false);
  const [currentImage, setCurrentImage] = useState(null);
  const [cleanupTips, setCleanupTips] = useState([]);
  const [cleanupProgress, setCleanupProgress] = useState({});
  const [progressMessage, setProgressMessage] = useState("");
  const [completedTasksCount, setCompletedTasksCount] = useState(0);
  const [totalTasksCount, setTotalTasksCount] = useState(0);
  const [referenceImage, setReferenceImage] = useState(null);
  
  // Nouveaux √©tats pour l'assistant conversationnel
  const [isListening, setIsListening] = useState(false);
  const [isDescribing, setIsDescribing] = useState(false);
  const [assistantMode, setAssistantMode] = useState('cleanup'); // 'cleanup', 'describe', 'chat'
  const [conversation, setConversation] = useState([]);
  const [currentObjectDescription, setCurrentObjectDescription] = useState("");
  
  const detectionIntervalRef = useRef(null);
  const videoRef = useRef(null);
  const recognitionRef = useRef(null);

  // Charger l'image de r√©f√©rence
  useEffect(() => {
    const fetchReferenceImage = async () => {
      try {
        const response = await fetch("http://127.0.0.1:8000/chambre/get_reference/");
        if (response.ok) {
          const data = await response.json();
          if (data && data.image_path) {
            // R√©cup√©rer l'image depuis le chemin retourn√© par l'API
            setReferenceImage(`http://127.0.0.1:8000/uploads/${data.image_path.split('/').pop()}`);
          }
        } else {
          console.error("Erreur lors du chargement de l'image de r√©f√©rence");
        }
      } catch (error) {
        console.error("Erreur lors de la r√©cup√©ration de l'image de r√©f√©rence", error);
      }
    };

    fetchReferenceImage();
  }, []);

  // Initialiser la reconnaissance vocale
  useEffect(() => {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognitionRef.current = new SpeechRecognition();
      recognitionRef.current.continuous = false;
      recognitionRef.current.interimResults = false;
      recognitionRef.current.lang = 'fr-FR';
      
      recognitionRef.current.onresult = async (event) => {
        const transcript = event.results[0][0].transcript;
        console.log('Speech recognized:', transcript);
        await handleChildQuestion(transcript);
      };
      
      recognitionRef.current.onend = () => {
        setIsListening(false);
      };
      
      recognitionRef.current.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        setIsListening(false);
        speakText("Oups ! Je n'ai pas bien entendu ta question. Peux-tu r√©p√©ter ?");
      };
    }
  }, []);

  // Fonction pour g√©rer les questions des enfants
  const handleChildQuestion = async (question) => {
    try {
      const response = await fetch("http://127.0.0.1:8000/chat_with_assistant/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          message: question,
          context: "enfant"
        }),
      });

      const data = await response.json();
      
      if (data.success) {
        // Ajouter √† la conversation
        setConversation(prev => [
          ...prev,
          { type: 'child', message: question, timestamp: new Date() },
          { type: 'assistant', message: data.response, timestamp: new Date() }
        ]);
        
        // Parler la r√©ponse
        speakText(data.response);
      } else {
        speakText("D√©sol√©, je n'ai pas compris ta question. Peux-tu la r√©p√©ter ?");
      }
    } catch (error) {
      console.error('Error in chat:', error);
      speakText("Oups ! J'ai eu un petit probl√®me. Peux-tu r√©p√©ter ta question ?");
    }
  };

  // Fonction pour d√©crire un objet que l'enfant montre
  const describeObjectInHand = async () => {
    if (!videoRef.current || !isCameraOn || isDescribing) return;
    
    setIsDescribing(true);
    
    try {
      const video = videoRef.current;
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const context = canvas.getContext('2d');
      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Convertir en blob
      const blob = await new Promise((resolve) => {
        canvas.toBlob(resolve, 'image/jpeg', 0.8);
      });

      // Cr√©er FormData pour l'upload
      const formData = new FormData();
      formData.append('file', blob, 'object_to_describe.jpg');

      console.log('Sending image to describe_object endpoint...');
      
      const response = await fetch("http://127.0.0.1:8000/describe_object/", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log('Response from describe_object:', data);
      
      setCurrentObjectDescription(data.description);
      speakText(data.description);
      
      // Ajouter √† la conversation si un objet a √©t√© trouv√©
      if (data.object_found) {
        setConversation(prev => [
          ...prev,
          { 
            type: 'assistant', 
            message: data.description, 
            timestamp: new Date(),
            object_info: {
              name: data.object_name,
              color: data.color,
              size: data.size
            }
          }
        ]);
      }
      
    } catch (error) {
      console.error('Error describing object:', error);
      const errorMsg = "Oups ! Je n'arrive pas √† voir ton objet clairement. Peux-tu le montrer un peu plus pr√®s de la cam√©ra ?";
      setCurrentObjectDescription(errorMsg);
      speakText(errorMsg);
    } finally {
      setIsDescribing(false);
    }
  };

  // Fonction pour d√©marrer l'√©coute
  const startListening = () => {
    if (recognitionRef.current && !isListening) {
      setIsListening(true);
      recognitionRef.current.start();
      speakText("Je t'√©coute ! Pose-moi ta question !");
    }
  };

  // Lire les instructions √† haute voix quand de nouveaux objets sont d√©tect√©s
  useEffect(() => {
    if (assistantMode === 'cleanup' && cleanupTips && cleanupTips.length > 0) {
      // Introduction
      let fullText = "J'ai trouv√© des objets √† ranger! ";
      
      // Ajouter le message de progression si disponible
      if (progressMessage) {
        fullText += progressMessage + " ";
      }
      
      // Lister les objets trouv√©s
      if (cleanupTips.length === 1) {
        fullText += `Je vois ${cleanupTips[0].title}. ${cleanupTips[0].instruction}`;
      } else if (cleanupTips.length <= 3) {
        const objects = cleanupTips.map(tip => tip.title).join(", ");
        fullText += `Je vois: ${objects}. Commen√ßons par ranger ces objets un par un!`;
      } else {
        fullText += `Je vois ${cleanupTips.length} objets √† ranger. Commen√ßons par les premiers!`;
      }
      
      // Parler le texte complet
      setTimeout(() => {
        const success = speakText(fullText);
        if (!success) {
          console.warn("Synth√®se vocale non disponible");
        }
      }, 500); // Petit d√©lai pour s'assurer que l'UI est mise √† jour
    }
  }, [cleanupTips, progressMessage, assistantMode]);

  // Assistant vocal pour encourager les enfants
  useEffect(() => {
    if (assistantMode === 'cleanup' && completedTasksCount > 0 && totalTasksCount > 0) {
      const encouragements = [
        "Excellent travail! Continue comme √ßa!",
        "Bravo! Tu ranges tr√®s bien ta chambre!", 
        "Super! Tu es un vrai champion du rangement!",
        "Magnifique! Ta chambre devient de plus en plus belle!",
        "Formidable! Tu fais un travail fantastique!"
      ];
      
      let message = encouragements[Math.floor(Math.random() * encouragements.length)];
      
      if (completedTasksCount === totalTasksCount) {
        message = "F√©licitations! Tu as rang√© toute ta chambre! Tu es incroyable!";
      } else if (completedTasksCount / totalTasksCount >= 0.5) {
        message += " Tu as d√©j√† rang√© plus de la moiti√©!";
      }
      
      setTimeout(() => {
        speakText(message);
      }, 1000);
    }
  }, [completedTasksCount, totalTasksCount, assistantMode]);

  const startCamera = async () => {
    setError("");
    setDetectionResult(null);
    
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      const errorMsg = "Votre navigateur ne supporte pas l'acc√®s √† la cam√©ra.";
      setError(errorMsg);
      speakText("Oups! Ton navigateur ne peut pas utiliser la cam√©ra. Demande de l'aide √† un adulte.");
      return;
    }

    try {
      const constraints = {
        video: { 
          facingMode: "environment",
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false,
      };

      const streamData = await navigator.mediaDevices.getUserMedia(constraints);
      setStream(streamData);
      setIsCameraOn(true);
      
      if (videoRef.current) {
        videoRef.current.srcObject = streamData;
        // Attendre que la vid√©o soit pr√™te
        videoRef.current.onloadedmetadata = () => {
          speakText("Parfait! La cam√©ra est maintenant activ√©e. Montre-moi ta chambre pour que je puisse t'aider √† la ranger!");
        };
      }

      // Set initial game instructions
      setGameInstructions("Scanne ta chambre pour d√©tecter les jouets. Nous allons te guider pour les ranger!");
      
      // D√©marrer la d√©tection automatique apr√®s 2 secondes
      setTimeout(() => {
        if (streamData && streamData.active) {
          startAutoDetection();
        }
      }, 2000);
      
    } catch (err) {
      console.error("Camera access error:", err);
      let errorMessage = `Erreur d'acc√®s √† la cam√©ra: ${err.message}`;
      let spokenMessage = "Oups! Je n'arrive pas √† utiliser la cam√©ra. ";
      
      if (err.name === "NotAllowedError") {
        errorMessage = "Permission refus√©e. Veuillez autoriser l'acc√®s √† la cam√©ra.";
        spokenMessage += "Demande √† un adulte d'autoriser l'utilisation de la cam√©ra.";
      } else if (err.name === "NotFoundError") {
        errorMessage = "Aucune cam√©ra n'a √©t√© trouv√©e.";
        spokenMessage += "Il semble qu'aucune cam√©ra ne soit connect√©e.";
      } else if (err.name === "NotReadableError") {
        errorMessage = "La cam√©ra est d√©j√† utilis√©e par une autre application.";
        spokenMessage += "La cam√©ra est d√©j√† utilis√©e. Ferme les autres applications qui pourraient l'utiliser.";
      }
      
      setError(errorMessage);
      setIsCameraOn(false);
      speakText(spokenMessage);
    }
  };

  // Fonction pour d√©marrer la d√©tection automatique
  const startAutoDetection = () => {
    if (detectionIntervalRef.current) {
      clearInterval(detectionIntervalRef.current);
    }
    
    detectionIntervalRef.current = setInterval(() => {
      if (isCameraOn && !isDetectingState) {
        captureAndDetect();
      }
    }, detectionInterval);
  };

  const stopCamera = () => {
    if (stream) {
      stream.getTracks().forEach((track) => track.stop());
    }
    setIsCameraOn(false);
    setStream(null);
    setDetectionResult(null);
    
    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }
    
    if (detectionIntervalRef.current) {
      clearInterval(detectionIntervalRef.current);
      detectionIntervalRef.current = null;
    }
  };

  const captureAndDetect = async () => {
    if (!videoRef.current || !isCameraOn || isDetectingState) return;
    
    setIsDetectingState(true);
    setDetectionResult(null);

    try {
      const video = videoRef.current;
      
      // V√©rifier que la vid√©o est pr√™te
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        console.warn('‚ö†Ô∏è Vid√©o pas encore pr√™te, dimensions:', video.videoWidth, 'x', video.videoHeight);
        setTimeout(() => {
          setIsDetectingState(false);
          captureAndDetect(); // R√©essayer
        }, 500);
        return;
      }
      
      console.log('üìπ Capture vid√©o:', video.videoWidth, 'x', video.videoHeight);
      
      const canvas = document.createElement('canvas');
      // Utiliser une r√©solution optimale pour YOLOv5
      const targetWidth = 640;
      const targetHeight = 480;
      
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      const context = canvas.getContext('2d');
      
      // Dessiner l'image redimensionn√©e
      context.drawImage(video, 0, 0, targetWidth, targetHeight);
      
      console.log('üñºÔ∏è Canvas cr√©√©:', canvas.width, 'x', canvas.height);

      // Convertir en blob avec meilleure qualit√©
      const blob = await new Promise((resolve) => {
        canvas.toBlob(resolve, 'image/jpeg', 0.9); // Qualit√© augment√©e √† 0.9
      });
      
      console.log('üì¶ Blob cr√©√©, taille:', blob.size, 'bytes');

      // Cr√©er FormData pour l'upload
      const formData = new FormData();
      formData.append('file', blob, 'detection_image.jpg');

      console.log('üîç Envoi de l\'image pour d√©tection simple...');
      
      // Utiliser le nouvel endpoint simple
      const response = await fetch("http://127.0.0.1:8000/simple_detect_objects/", {
        method: "POST",
        body: formData,
      });

      console.log('üì° R√©ponse HTTP:', response.status, response.statusText);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erreur HTTP:', response.status, errorText);
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
      }

      const data = await response.json();
      console.log('üìã R√©ponse d√©taill√©e:', JSON.stringify(data, null, 2));
      
      if (data.success) {
        // Mettre √† jour les objets d√©tect√©s
        setDetectedObjects(data.detected_objects || []);
        
        console.log('üéØ Objets d√©tect√©s:', data.detected_objects?.length || 0);
        data.detected_objects?.forEach((obj, i) => {
          console.log(`  ${i+1}. ${obj.name} (${obj.color}, ${obj.size}) - conf: ${obj.confidence?.toFixed(2)}`);
        });
        
        // Annoncer les objets trouv√©s
        if (data.detected_objects && data.detected_objects.length > 0) {
          announceDetectedObjects(data.detected_objects);
        } else {
          // Annoncer qu'aucun objet n'a √©t√© trouv√© (occasionnellement)
          if (Math.random() < 0.3) { // 30% de chance
            speakText("Je ne vois aucun objet int√©ressant pour le moment. Montre-moi autre chose !");
          }
        }
        
        setDetectionResult({
          success: true,
          message: data.message
        });
      } else {
        setDetectionResult({
          success: false,
          message: data.message || "Probl√®me de d√©tection"
        });
        speakText("Oups! J'ai eu un petit probl√®me pour analyser l'image. Essayons encore!");
      }
      
    } catch (error) {
      console.error("‚ùå Erreur de d√©tection:", error);
      const errorMsg = `Erreur: ${error.message}`;
      setDetectionResult({
        success: false,
        message: errorMsg
      });
      speakText("Oups! J'ai eu un probl√®me pour voir l'image. R√©essayons dans quelques secondes!");
    } finally {
      setIsDetectingState(false);
    }
  };

  const handleIntervalChange = (e) => {
    const newInterval = parseInt(e.target.value);
    setDetectionInterval(newInterval);
    
    if (isCameraOn && detectionIntervalRef.current) {
      clearInterval(detectionIntervalRef.current);
      detectionIntervalRef.current = setInterval(captureAndDetect, newInterval);
    }
  };

  const markItemAsComplete = async (id) => {
    try {
      // Appeler l'API pour incr√©menter le compteur de t√¢ches
      const response = await fetch("http://127.0.0.1:8000/complete_task/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        }
      });

      if (!response.ok) {
        throw new Error("Erreur lors de l'enregistrement de la t√¢che termin√©e");
      }

      const data = await response.json();
      
      // Mettre √† jour l'√©tat local
      setCleanupProgress(prev => ({
        ...prev,
        [id]: true
      }));
      
      // Mettre √† jour le compteur et le message
      setCompletedTasksCount(data.completed_tasks);
      setProgressMessage(data.progress_message);
      
      // Annoncer le message d'encouragement
      const speechMessage = new SpeechSynthesisUtterance(data.progress_message);
      speechMessage.lang = 'fr-FR';
      window.speechSynthesis.speak(speechMessage);
      
      // V√©rifier si toutes les t√¢ches sont compl√©t√©es
      const allCompleted = Object.values({
        ...cleanupProgress,
        [id]: true
      }).every(Boolean) && cleanupTips.length > 0;
      
      if (allCompleted) {
        setGameInstructions("F√©licitations! Tu as rang√© tous les objets! ");
      }
      
    } catch (error) {
      console.error("Erreur:", error);
    }
  };

  const resetCleanupProgress = async () => {
    try {
      // Appeler l'API pour r√©initialiser le compteur
      const response = await fetch("http://127.0.0.1:8000/reset_tasks/", {
        method: "POST",
      });

      if (!response.ok) {
        throw new Error("Erreur lors de la r√©initialisation des t√¢ches");
      }

      // R√©initialiser l'√©tat local
      const newProgress = {};
      cleanupTips.forEach(tip => {
        newProgress[tip.id] = false;
      });
      
      setCleanupProgress(newProgress);
      setCompletedTasksCount(0);
      setProgressMessage("");
      
    } catch (error) {
      console.error("Erreur:", error);
    }
  };

  useEffect(() => {
    if (isCameraOn) {
      detectionIntervalRef.current = setInterval(captureAndDetect, detectionInterval);
      return () => {
        if (detectionIntervalRef.current) {
          clearInterval(detectionIntervalRef.current);
        }
      };
    } else if (detectionIntervalRef.current) {
      clearInterval(detectionIntervalRef.current);
      detectionIntervalRef.current = null;
    }
  }, [isCameraOn, detectionInterval]);

  useEffect(() => {
    return () => {
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
      }
      if (detectionIntervalRef.current) {
        clearInterval(detectionIntervalRef.current);
      }
    };
  }, [stream]);

  const startDetection = () => {
    if (!isCameraOn) {
      speakText("Allume d'abord la cam√©ra pour que je puisse voir !");
      return;
    }

    setIsDetecting(true);
    speakText("Je commence √† regarder les objets devant moi !");
    
    // D√©tecter imm√©diatement puis toutes les 3 secondes
    captureAndDetect();
    detectionIntervalRef.current = setInterval(captureAndDetect, detectionInterval);
  };

  const stopDetection = () => {
    if (detectionIntervalRef.current) {
      clearInterval(detectionIntervalRef.current);
      detectionIntervalRef.current = null;
    }
    setIsDetecting(false);
    setDetectedObjects([]);
    speakText("J'arr√™te de regarder les objets.");
  };

  const announceDetectedObjects = (objects) => {
    if (objects.length === 0) return;

    // Cr√©er l'annonce
    let announcement = "";
    
    if (objects.length === 1) {
      const obj = objects[0];
      announcement = `Je vois ${getArticle(obj.class)} ${obj.class}`;
      
      // Ajouter la couleur si disponible
      if (obj.color) {
        announcement += ` de couleur ${obj.color}`;
      }
      
      // Ajouter la taille si disponible
      if (obj.size) {
        announcement += ` de taille ${obj.size}`;
      }
      
      announcement += " !";
    } else {
      announcement = `Je vois ${objects.length} objets : `;
      const objectNames = objects.map(obj => `${getArticle(obj.class)} ${obj.class}`);
      announcement += objectNames.join(", ") + " !";
    }

    // √âviter les r√©p√©titions trop fr√©quentes
    if (announcement !== lastAnnouncement) {
      setLastAnnouncement(announcement);
      speakText(announcement);
      
      // R√©initialiser apr√®s le cooldown
      setTimeout(() => {
        setLastAnnouncement("");
      }, 5000);
    }
  };

  const getArticle = (objectName) => {
    const feminineWords = ['pomme', 'balle', 'voiture', 'chaise', 'table', 'bouteille'];
    return feminineWords.some(word => objectName.toLowerCase().includes(word)) ? 'une' : 'un';
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-400 via-purple-500 to-pink-500 p-4">
      <div className="max-w-4xl mx-auto">
        {/* En-t√™te */}
        <div className="text-center mb-6">
          <h1 className="text-4xl font-bold text-white mb-2">
            üé• D√©tecteur d'Objets Magique !
          </h1>
          <p className="text-white text-lg">
            Je regarde devant moi et je te dis tout ce que je vois !
          </p>
        </div>

        {/* Zone vid√©o */}
        <div className="bg-white rounded-2xl shadow-2xl p-6 mb-6">
          <div className="relative">
            <video
              ref={videoRef}
              className="w-full h-96 bg-gray-900 rounded-xl object-cover"
              autoPlay
              playsInline
              muted
            />
            
            {/* Overlay des objets d√©tect√©s */}
            {detectedObjectsState.length > 0 && (
              <div className="absolute top-4 left-4 bg-black bg-opacity-70 text-white p-3 rounded-lg">
                <div className="text-sm font-semibold mb-1">Objets d√©tect√©s :</div>
                {detectedObjectsState.map((obj, index) => (
                  <div key={index} className="text-xs">
                    üîç {obj.class} {obj.color && `(${obj.color})`} {obj.size && `- ${obj.size}`}
                  </div>
                ))}
              </div>
            )}

            {/* Indicateur de d√©tection */}
            {isDetecting && (
              <div className="absolute top-4 right-4 bg-green-500 text-white px-3 py-1 rounded-full text-sm font-semibold animate-pulse">
                üëÄ Je regarde...
              </div>
            )}
          </div>
        </div>

        {/* Contr√¥les */}
        <div className="bg-white rounded-2xl shadow-xl p-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            
            {/* Contr√¥les de la cam√©ra */}
            <div className="space-y-4">
              <h3 className="text-xl font-bold text-gray-800 mb-3">üìπ Cam√©ra</h3>
              
              {!isCameraOn ? (
                <button
                  onClick={startCamera}
                  className="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-xl transition-colors text-lg"
                >
                  üé• Allumer la Cam√©ra
                </button>
              ) : (
                <button
                  onClick={stopCamera}
                  className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-xl transition-colors text-lg"
                >
                  ‚èπÔ∏è √âteindre la Cam√©ra
                </button>
              )}
            </div>

            {/* Contr√¥les de d√©tection */}
            <div className="space-y-4">
              <h3 className="text-xl font-bold text-gray-800 mb-3">üëÅÔ∏è D√©tection</h3>
              
              {!isDetecting ? (
                <button
                  onClick={startDetection}
                  disabled={!isCameraOn}
                  className={`w-full font-bold py-3 px-6 rounded-xl transition-colors text-lg ${
                    isCameraOn 
                      ? 'bg-blue-500 hover:bg-blue-600 text-white' 
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  üëÄ Commencer √† Regarder
                </button>
              ) : (
                <button
                  onClick={stopDetection}
                  className="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-xl transition-colors text-lg"
                >
                  ‚è∏Ô∏è Arr√™ter de Regarder
                </button>
              )}
            </div>
          </div>

          {/* Messages d'erreur */}
          {error && (
            <div className="mt-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-xl">
              <div className="flex items-center">
                <span className="text-xl mr-2">‚ö†Ô∏è</span>
                <span>{error}</span>
              </div>
            </div>
          )}

          {/* Derni√®re annonce */}
          {lastAnnouncement && (
            <div className="mt-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-xl">
              <div className="flex items-center">
                <span className="text-xl mr-2">üó£Ô∏è</span>
                <span className="font-semibold">Derni√®re annonce : {lastAnnouncement}</span>
              </div>
            </div>
          )}

          {/* Instructions */}
          <div className="mt-6 bg-blue-50 p-4 rounded-xl">
            <h4 className="font-bold text-blue-800 mb-2">üìù Comment √ßa marche :</h4>
            <ol className="text-blue-700 text-sm space-y-1">
              <li>1. üé• Clique sur "Allumer la Cam√©ra"</li>
              <li>2. üëÄ Clique sur "Commencer √† Regarder"</li>
              <li>3. üó£Ô∏è Montre des objets devant la cam√©ra</li>
              <li>4. üëÇ √âcoute mes annonces !</li>
            </ol>
          </div>
        </div>
      </div>
    </div>
  );
};

export default RoomOrganizer;